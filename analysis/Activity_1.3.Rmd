### Activity 1.3: Data Structures ###
========================================================
#### Activity 1.3.1:  Numeric vectors
Numeric vectors are the fundamental building blocks of R. Most of the techniques shown in this activity apply to any type of vector, be it a numeric, character, or logical vector.

Suppose you wish to create an object 'x' and assign it a value of 5.  There are two ways to do this:

```{r}
x = 5
x <- 5
```

Display the object:
```{r}
x
```

Note that R is CaSe SenSiTivE!
```{r}
w <- 10
W <- 12
```

The `cat()` function prints text to the screen, which is useful for writing. messages
```{r}
cat("Little w =", w, "is different than big W =", W, "\n")
```


You can create a numeric vector from 1 to 6 in three different ways.
```{r}
x0 <- c(1, 2, 3, 4, 5, 6)
x1 <- seq(1, 6, by = 1)
x2 <- 1:6
```

View these three objects:
```{r}
x0
x1
x2
```


Here's a sequence from 1 to 22 stepping by 3.
```{r}
x <- seq(1, 22, by = 3)
x
```

This operation will square the elements of x. This is a 'vectorized' calculation. This means it squares each element indvidually and so there is no need to loop over each element.
```{r}
y <- x^2
y
```

Assign a value to m:
```{r}
m = 0.5
```

Another vectorized calculation:  multiple each element of `y` by `m`:
```{r}
y * m
```

Take the natural logarithm of each element of `y`:
```{r}
log(y)
```

Add two sequences together, elementwise:
```{r}
1:3 + 2:4
```

Suppose a vector is so long that we don't want to display all of it. Let's create a vector of 500 random numbers from a normal distribution with mean of 3 and standard deviation of 2.
```{r}
x <- rnorm(500, mean = 3, sd = 2)
```


The `str()` (structure) function tells us what type of object `x` is and provides some examples of the first few values.
```{r}
str(x)
```

The `length()` function returns the number of elements in `ÃŸx`.
```{r}
length(x)
```

We can calculate the sum, mean, max, min, and standard deviation.
```{r}
sum(x)
mean(x)
max(x)
min(x)
sd(x)
```

The `summary()` function provides summary statistics.
```{r}
summary(x)
```

The `head()` and `tail()` functions shows the first or last 6 elements, respectively.
```{r}
head(x)
tail(x)
```

We can easily extract elements of vectors.  For example, let's grab the 7th element of `y`:
```{r}
y <- 1:10
y[7]
```

Or let's select the 1st, 3rd, and 5th elements of `y`:
```{r}
y[c(1,3,5)]
```

Or the 6th through 8th elements:
```{r}
y[6:8]
```

To select elements that are less than 4, we first make an indicator, which 
is a vector of TRUE and FALSE elements indicating whether the elements are 
less than 4.
```{r}
indicator <- y < 4
indicator
```

And now we select elements that are less than 4 from y:
```{r}
y[indicator]
```

Another useful tool for generating vectors is the `rep()` function.  A 
vector of seven 1's:
```{r}
z <- rep(1, 7)
z
```

A sequence of 1 to 5, repeated twice
```{r}
rep(1:5, 2)
```

Another style of repeating, elementwise
```{r}
rep(1:5, each = 2)
```

#### Exercise 1.3.1:  Numeric Vectors

1) Create a vector from 3 to 11, in steps of 2

2) Create another vector from 12 to 4 in steps of -2

3) Display the last 2 elements of the second vector

4) Calculate the mean of the element-wise product of these
two vectors



#### Activity 1.3.2:  Character vectors

Character vectors allow you to store non-numeric data.  They are used in R all the time.

We refer to vectors of characters as strings. To create a character vector, we do the following:
```{r}
x = c("this", "that", "those")
x
```

Extracting characters is the same as extracting elements.
```{r}
x[2:3]
```

There are numerous functions for parsing, searching, and connecting text.  For example:
```{r}
y <- c("cat", "dog", "fish")
paste(x, y)
```

Or we can extract parts of the strings, known as substrings. In this case, we extract the first 3 letters of each element, beginning at position 1, ending at position 3.
```{r}
substr(x, 1, 3)
```

Count the number of characters in each element:
```{r}
nchar(x)
```

Search for the string "s" in each element of `x` and return a logical vector.
```{r}
sIndicator <- grepl("s", x)
sIndicator
```

Select only those words that have "s"
```{r}
x[sIndicator]
```


We can test if a value is in the string using `%in%`. Here, we use an indicator
variable to subset the original vector.
```{r}
mammalIndicator <- y %in% c("cat", "dog")
mammalIndicator
```

Now select the mammals from y:
```{r}
y[mammalIndicator]
```

Regarding quotes:  R will accept double or single quotes for all character 
strings.  Use both in the same statement if you need to nest them.
```{r}
x <- "A string with 'inner quotes'"
x
cat(x, "\n")
```

#### Exercise 1.3.2:  Character vectors

1) Create a character vector consisting of nouns (of the
length of your choosing)

2) Create a second character vector of same length with verbs

3) Paste the two vectors together

4) Count the total number of characters in the entire noun
vector.  Hint, use the `sum` function


#### Activity 1.3.3:  Logical vectors
Logical, or boolean, vectors are used to select subsets of data and define 
logical expressions in R programming.

To create a logical vector:
```{r}
z <- c(TRUE, FALSE, TRUE, TRUE)
z
```

Or, equivalently:
```{r}
z <- c(T, F, T, T)
z
```

We can select elements like any other vector.
```{r}
z[c(2,4)]
```

The which() function returns the indexes of a logical vector that are TRUE.
```{r}
which(z)
```

And we can summarize over each element in the vector.  For example, the 
`any()` function returns TRUE if any elements are TRUE.

```{r}
any(z)
```

And the `all()` function returns TRUE if all elments are TRUE.
```{r}
all(z)
```

We can also count the number of true values in a logical vector using the 
`sum()` function.
```{r}
sum(z)
```

And we can negate a logical vector:
```{r}
!z
```

Let's create another logical vector, which will be TRUE for the elements of 
1,2,3,4 that are <= 2.
```{r}
y <- 1:4 <= 2
y
```

We can perform 'and' comparisons betwen two logical vectors, elementwise:
```{r}
z & y
```

As well as 'or' comparisons, elementwise:
```{r}
z | y
```

#### Exercise 1.3.3:  Logical vectors

1) Create random numeric vector of length 1000 with values
uniformly chosen between 0 and 1.  Hint: use the 'runif'
function

2) Count the number of elements in the vector that
fall in the interval [0.2, 0.8].  On average, it should
be 600


#### Activity 1.3.4:  Integer and complex vectors


For most applications in R, it will likely not make a difference if you 
represent integer values as 'numeric'. The difference between the 'integer' 
and 'numeric' classes is that objects of class 'integer' are coded
as type 'int' in the primitive C or Fortran code that is running underneath 
the R interpeter, and objects of class 'numeric' are usually typed as 
'double'.  But it might be important to you in some cases.

Notice this results in an integer:
```{r}
x <- 1:3
str(x)
is.integer(x)
```

Whereas these end up being numeric:
```{r}
str(c(1, 2, 3))
str(seq(1, 3, 1))
```

There are two fullproof ways to create integer vectors. Here are two identical approaches:
```{r}
x1 <- as.integer(c(1, 5, -2))
x2 <- c(1L, 5L, -2L)
x1
x2
```

Note how they are identical (not juse in value, but also in type).

```{r}
identical(x1, x2)
```

Whereas if we create a numeric vector, they are not identical because x1 is 
of class 'integer' and x3 is of class 'numeric'.
```{r}
x3 <- c(1, 2, 3)
identical(x1, x3)
```

R can also store and perform mathematical operations with complex values 
`(a + bi)`.  Here's a complex vector:
```{r}
v1 <- complex(real = 1:3, imaginary = 4:6)
v1
str(v1)
```

And here are some operations on the complex vector, the sum, and extracting 
the real and imaginary portions of the vector:

```{r}
sum(v1)
Re(v1)
Im(v1)
```

Type `?complex` in R for more details.


#### Activity 1.3.5:  Named vectors

The elements of vectors in R can be named for convenience.
Here's how to create a named vector.

```{r}
aNamedVec <- c(type = 1, count = 7, max = 10)
aNamedVec
```

You can also assign names using quoted strings, which can include spaces 
or special characters:
```{r}
bNamedVec <- c("a type" = 1, "b%type" = 7)
bNamedVec
```

And you can extract elements of a named vector by the names. Notice how the 
name is displayed, along with the value of the vector.
```{r}
aNamedVec["type"]
```

Suppose you would like extract the element without the name. You can do this 
using the 'double brace' syntax:
```{r}
aNamedVec[["type"]]
```

And you can extract more than one element:
```{r}
aNamedVec[c("type", "max")]
```

But attempting to strip the names when you extract more than one element doesn't work:
```{r}
try(aNamedVec[[c("type", "max")]])
```

Speaking of removing names, here's how you can do that:
```{r}
names(aNamedVec) <- NULL
aNamedVec
```

And you can use `names()` to put the names back in again, or to change the names.
```{r}
names(aNamedVec) <- c("type1", "count1", "max1")
aNamedVec
```

And you can extract the names as well.
```{r}
names(aNamedVec)
```

These naming principles apply to any type of vector: integer, numeric, 
character, logical, or complex.


#### Exercise 1.3.5: Named vectors


1) Create a named character vector of length 3

2) Create a second named logical vector of length 3

3) Switch the names of the 2 vectors


#### Activity 1.3.6:  Data frames

Data frames consist of rows and columns (like a spreadsheet). They are the most
common way to store data in R.  Columns can be of any type:  numeric, 
character, logical, complex, or factors. (We haven't learned about 
factors--that's a more advanced topic).

Here's how we could manually create a simple data frame.
```{r}
df <- data.frame(a = 1:6, b = letters[1:6],
                 c = rep(c(TRUE, FALSE), each = 3))
df
```

And here's a more interesting data frame with the specs of various automobiles 
that is included in the datasets package that comes with R:
```{r}
mtcars
```

There are a number of tools to extract info from data frames and create subsets.

The `str()` function tells the names and types of variables in the data frame.
```{r}
str(mtcars)
```

Use `head()` to look at the first 6 rows of the data frame.
```{r}
head(mtcars)
```

We can display the number of rows:
```{r}
nrow(mtcars)
```

We can display the number of columns:
```{r}
ncol(mtcars)
```

We can extract the row names as a character vector:
```{r}
rownames(mtcars)
```

We can extract the colum names as a character vector:
```{r}
colnames(mtcars)
```

And we can see summaries of each column:
```{r}
summary(mtcars)
```

We can subset a data frame similar to the way we extracted elements from 
vectors.  For example, let's extract the 3rd row and 4th column of mtcars

```{r}
mtcars[3, 4]
```

Equivalently, we could have used the row and column name to extract the data:
```{r}
mtcars["Datsun 710", "hp"]
```

In general, using the row and column name is a better programming practice 
than using just the row or column numbers because it makes code easier to 
read and there's no mistaking which rows or columns were selected.

These two statements give the same result. 

```{r}
mtcars[3:5, ]
mtcars[c("Datsun 710", "Hornet 4 Drive", "Hornet Sportabout"),]
```

Or extract multiple rows and columns simultaneously.
These are equivalent:
```{r}
mtcars[c(1,30), c(1, 5:7)]
mtcars[c("Mazda RX4", "Ferrari Dino"), c("mpg", "drat",
                                         "wt", "qsec")]
```

Suppose we wish to look at the vehicles that have high power but still good gas mileage: e.g. cars with `horsepower > 150` and `mpg > 15`.

```{r}
indicator <- (mtcars[,"hp"] > 150) & (mtcars[,"mpg"] > 15)
mtcars[indicator, c("hp", "mpg")]
```

Suppose we wish to exclude Japanese-made cars from the data:
```{r}
japanese <- c("Mazda RX4", "Mazda RX4 Wag", "Datsun 710",
              "Honda Civic", "Toyota Corolla", "Toyota Corona")
japaneseInd <- rownames(mtcars) %in% japanese
nonJapan <- mtcars[!japaneseInd,]
```

Did we get them all?  If so, these two numbers should be the same:
```{r}
nrow(mtcars) - nrow(nonJapan)
length(japanese)
```

And as if there weren't enough options, a single column can be extracted 
from a data frame using the $.
For example, let's get the number of gears.
```{r}
gears <- mtcars$gear
```

Notice it's a numeric vector.
```{r}
str(gears)
```

And we can tabulate the number of vehicles with 3, 4, or 5 gears:
```{r}
table(gears)
```

Last of all, for variables that are discrete (with relatively few values, 
we might want to do a cross tabluation.  Here's an example comparing the 
number of gears to the number of cylinders.

```{r}
table(mtcars[,c("cyl", "gear")])
```

#### Exercise 1.3.6: Data frames


1) Create a data frame with at least 7 rows with the
following columns:
    1. A character vector consisting of some repetition of
       the letters 'a', 'b' and 'c'
    2. A numeric vector of randomly generated numbers between
       0 and 1.  Hint:  use runif()
    3. A second numeric vector of randomly generated numbers
       between 2 and 7.  Hint: use runif() again

 2) Display the number of rows of the data frame

 3) Assign rownames consisting of capital letters, 'A', 'B',
    'C', etc.  Hint, use the `LETTERS` object that is part of
    R

 4) Display the second column of the fourth and fifth rows
    using the row and column names of the data frame

 5) Create a subset of the data by selecting those observations
    meet all of the following criteria:
    a.  The character vector has a value of 'b' or 'c'
    b.  The value of the first numeric vector is greater than
        0.1
    c.  The value of the second numeric vector is less than
        6.


#### Activity 1.3.7: Matrices

Matrices in R are similar to data frames, with one key
difference:  all elements in a data frame must be the same
type: either integer, numeric, character, logical, or complex.


Here is a simple matrix of integers.  Notice how R loads
the matrix columnwise by default.

```{r}
m1 <- matrix(1:15, nrow = 5, ncol = 3)
m1
str(m1)
```

We could also load the matrix rowwise:
```{r}
m1 <- matrix(1:15, nrow = 5, ncol = 3, byrow = TRUE)
m1
```

We can add column names and rownames:
```{r}
rownames(m1) <- paste("Row", 1:5, sep = "")
colnames(m1) <- paste("Col", 1:3, sep = "")
m1
```

Alternatively, we can add in the row and column names from
the start when we build the matrix using the `dimnames` argument.

```{r}
m1 <- matrix(1:15, nrow = 5, ncol = 3,
             dimnames = list(paste("Row", 1:5, sep = ""),
                             paste("Col", 1:3, sep = "")))
m1
```


We can also use rownames() and colnames() to extract names from the matrix.

```{r}
rownames(m1)
colnames(m1)
```

We can get summary information about the matrix, like the total number of 
elements, using `length()`.
```{r}
length(m1)
```

The number of columns:
```{r}
ncol(m1)
```

And the number of rows:
```{r}
nrow(m1)
```

As with data frames, we can extract elements using row and column names:
```{r}
m1[c("Row1", "Row3"), c("Col1", "Col2")]
```

Or we can extract using row/column indexes:
```{r}
m1[c(1, 3), 1:2]
```

Likewise, we can create a matrix of of other types.  Let's  create a matrix 
of boolean values (logicals).  In this case, we'll start with a random vector 
of length 9 that consists of TRUEs and FALSEs using the sample() function.
```{r}
x <- sample(c(TRUE, FALSE), 9, replace = TRUE)
```

To build the matrix, notice that we only need to specify the number of rows, 
or the number of columns, but not both.
This is because the length of `x`, combined the row or column number is 
sufficient to define the matrix.
```{r}
m2 <- matrix(x, ncol = 3)
m2
str(m2)
```

And you can melt a matrix back into a vector using `as.vector()`.
```{r}
x1 <- as.vector(m2)
x1
identical(x, x1)
```

You can also create a matrix of empty values.
```{r}
matrix(NA,  ncol = 2, nrow = 2)
```

Or a matrix of repeated values.
```{r}
matrix(1,   ncol = 2, nrow = 2)
matrix(1:2, ncol = 2, nrow = 2)
```

But if the vector you provide doesn't divide evenly into the number of matrix elements, you get warned:
```{r}
matrix(1:3, ncol = 2, nrow = 2)
```

All the standard matrix operations are available in R. Let's create a set of conformable column vectors and matrices to illustrate:
```{r}
v1 <- 1:3
v2 <- 4:6
m1 <- matrix(c(3, 11, 16, 1, 4, 1, 4, 14, 19), nrow = 3)
m2 <- matrix(1:9, ncol = 3)
```

Transpose the column vector to create a row vector.
```{r}
t(v1)
```

Transpose the matrix.
```{r}
t(m1)
```

Inner product of two vectors.  Notice it returns a 1 x 1 matrix.
```{r}
t(v1) %*% v2
```

If you want to just have a simple vector (non-matrix) object returned after 
calculating the inner product:
```{r}
as.vector(t(v1) %*% v2)
```

Outer product of two vectors:
```{r}
v1 %*% t(v2)
```

Matrix multiplication:
```{r}
m1 %*% m2
```

Matrix inversion:
```{r}
solve(m1)
```

Calculate eigenvectors and eigenvalues:
```{r}
eigen(m2)
```

Calculate the determinant:
```{r}
det(m1)
```

Extract the diagonal elements:
```{r}
diag(m2)
```

Stack matrices on top of each other using "row bind":
```{r}
rbind(m1, m2)
```

Join matrices side by side using "column bind":
```{r}
cbind(m1, m2)
```

By the way, `rbind()` and `cbind()` work the same way for data frames too, so 
long as the variable types and the dimensions of the data frames are conformable.

Elementwise arithmetic operations
```{r}
m1 + m2
m1 - m2
m1 * m2
m1 / m2
```

Add all the elements in the matrix:
```{r}
sum(m1)
```

Take the product of all the elments in the matrix:
```{r}
prod(m1)
```

Calculate the sums of the rows, of the columns:
```{r}
rowSums(m1)
colSums(m1)
```

Calculate the means of the rows, of the columns:
```{r}
rowMeans(m1)
colMeans(m1)
```

Use the sums to get the same results as the rowMeans:
```{r}
colSums(m1) / nrow(m1)
```

Create a 5 x 5 identity matrix:
```{r}
diag(5)
```


#### Exercise 1.3.7: Matrices

 1) Create a 2 x 2 matrix with the following elements:
    (2, 4, 7, 1), loaded rowwise.

 2) Calculate the trace (the sum of the diagonal elements)
    of the matrix.  Hint: use the `sum()` function

 3) Create a column vector of length 2 with the elements
    (3, 5)

 4) Using matrix multiplication, and your results from (1)
    and (3), find the product of the transpose of the column
    vector, the matrix, and the column vector.  Display the
    result should as a single number (not a 1 x 1 matrix).


#### Activity 1.3.8: Lists

 Lists are one of the most flexible objects in R.  A list is
 a collection of R objects--and these objects do not have to
 be of any particular type or size.  These objects can even
 be other lists.

 Let's build a simple list.  Notice how the elements are quite
 heterogenous (different data types, different lengths)
```{r}
aList <- list(a = 1:5, b = rep(TRUE, 2), c = letters[1:3])
aList
str(aList)
```

We can extract the names:
```{r}
names(aList)
```

And we can assign new names:
```{r}
names(aList) <- c("a.new", "b.new", "c.new")
aList
```

We can extract elements of the list using indexes, where
the double-brace [[]] notation removes the name.
```{r}
aList[1]
aList[[1]]
```

We can also extract elements by names:
```{r}
aList["b.new"]
aList[["b.new"]]
```

Like dataframes, we can also extract single elements from
a list using the '$', just like we can with data frames.

```{r}
aList$b.new
```

And we can extract multiple elements as well.
```{r}
aList[c("c.new", "b.new")]
```

But if we use the double bracket with more than one element,
we end up with trouble.
```{r}
try(aList[[c("c.new", "b.new")]])
```

The length() function returns the number of elements.
```{r}
length(aList)
```

Let's create a new list:
aNewList
```{r}
aNewList <- list(d = "nice", e = 12.7,
                 f = complex(real = 1, imaginary = 7))
```

And append the new list to the first list using `c()`.
```{r}
bList <- c(aList, aNewList)
bList
```

We can individually operate on each element in the list
as well, using `lapply()`.  For example, suppose we wanted
to know the length of each element in the list:
```{r}
lapply(bList, length)
```

Or suppose we wish to test whether each element is of type
"character", which we can do using the `is.character()` function.
```{r}
lapply(bList, is.character)
```

Or perhaps we wish to convert every element into a character
vector, using as.character().
```{r}
str(lapply(bList, as.character))
```

If we want to deconstruct the list into a single vector,
we can use `unlist()`, which will create chose the type of
the resulting vector.
```{r}
unlist(aList)
```

Here's another example of `unlist` with numeric vectors:
```{r}
cList <- list(a = 1:3, b = 4:10)
cList
unlist(cList)
```

We could remove the names from "aList":
```{r}
names(aList) <- NULL
aList
```

But without names, you can only access the elements with.
index numbers.
```{r}
aList[2:3]
```

However, you can still use `lapply()` with a list that
doesn't have names.  Here we're applying the `names()` function
to each element of the list. The resulting NULL output
for each element confirms the names are indeed gone.
```{r}
lapply(aList, names)
```

Notice how adding unlist() collapes the output into a vector.
```{r}
unlist(lapply(aList, is.numeric))
```

And you can create a list without names from the start.
```{r}
dList <- list(1:10, rep(TRUE, 2), rnorm(3), diag(2))
dList
```

Last of all, there is an important connection between
lists and data frames.  Data frames are special cases of
lists!  A data frame is a list of vectors of potentially
different types that all have the same length.


#### Exercise 1.3.8: Lists

 1) Create a named list with 3 elements:  a character vector,
    a numeric vector, and a 2 x 2 matrix

 2) Extract the third and first elements of the list,
    in that order

 3) Extract the 2nd element without the elment name

 4) Calculate the length of each element of the list and
    return the result as a vector


